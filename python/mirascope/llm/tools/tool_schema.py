"""The `ToolSchema` class for defining tools that LLMs can request be called."""

from __future__ import annotations

import inspect
from collections import namedtuple
from collections.abc import Awaitable, Callable
from dataclasses import dataclass
from typing import (
    Annotated,
    Any,
    Generic,
    TypeGuard,
    get_args,
    get_origin,
    get_type_hints,
)

from docstring_parser import parse
from pydantic import BaseModel, Field, create_model
from pydantic.fields import FieldInfo
from typing_extensions import Self

from ..types import Jsonable, JsonableCovariantT, P

DocstringArg = namedtuple("DocstringArg", ["name", "description"])


@dataclass
class ParsedDocstring:
    args: list[DocstringArg]


def _parse_docstring_params(docstring: str | None) -> ParsedDocstring:
    """Parse parameter descriptions from a docstring.

    Uses docstring-parser library which supports ReST, Google, Numpydoc-style and
    Epydoc docstrings

    Args:
        docstring: The function's docstring

    Returns:
        ParsedDocstring containing parameter descriptions
    """
    if not docstring:
        return ParsedDocstring(args=[])

    parsed = parse(docstring)
    args = []

    for param in parsed.params:
        if param.description:
            args.append(
                DocstringArg(name=param.arg_name, description=param.description)
            )

    return ParsedDocstring(args=args)


class ToolParameterSchema(BaseModel):
    """JSON Schema for tool parameters (always an object with properties).

    This contains real JSON Schema as generated by Pydantic, with full support
    for complex schemas like anyOf, nested objects, validation constraints, etc.
    Including $defs for complex type references.
    """

    properties: dict[str, dict[str, Any]] = Field(default_factory=dict)
    """Dictionary mapping parameter names to their JSON Schema definitions."""

    required: list[str] = Field(default_factory=list)
    """List of required parameter names."""

    additionalProperties: bool = False
    """Whether additional properties beyond those defined are allowed."""

    defs: dict[str, dict[str, Any]] | None = Field(default=None, alias="$defs")
    """JSON Schema definitions for complex types referenced via $ref."""


@dataclass
class ToolSchema(Generic[P, JsonableCovariantT]):
    """Base class defining a tool that can be used by LLMs.

    A Tool represents a function that can be called by an LLM during a call.
    It includes metadata like name, description, and parameter schema.

    This class is not instantiated directly but created by the `@tool()` decorator.
    """

    name: str
    """The name of the tool, used by the LLM to identify which tool to call."""

    description: str
    """Description of what the tool does, extracted from the function's docstring."""

    parameters: ToolParameterSchema
    """JSON Schema describing the parameters accepted by the tool."""

    strict: bool
    """Whether the tool should use strict mode when supported by the model."""

    @classmethod
    def create_schema(
        cls,
        fn: Callable[..., Jsonable] | Callable[..., Awaitable[Jsonable]],
        *,
        strict: bool = False,
    ) -> ToolSchema:
        """Create a `ToolSchema` by inspecting a function and its docstring.

        Uses Pydantic's create_model to dynamically build a model from the function
        signature, then extracts the JSON schema from it. This leverages Pydantic's
        robust type conversion and union handling.

        Args:
            fn: The function to extract schema from
            strict: Whether the tool should use strict mode when supported

        Returns:
            a `ToolSchema` representing the function
        """
        name = fn.__name__
        description = inspect.cleandoc(fn.__doc__) if fn.__doc__ else name

        param_descriptions = _parse_docstring_params(fn.__doc__)

        field_definitions = {}
        hints = get_type_hints(fn, include_extras=True)

        for param in inspect.signature(fn).parameters.values():
            if param.name in ("self", "cls"):
                continue

            param_type = hints.get(param.name, Any)
            default = ... if param.default is inspect.Parameter.empty else param.default
            field_info = None

            if get_origin(param_type) is Annotated:
                args = get_args(param_type)
                param_type = args[0]
                for annotation in args[1:]:
                    if isinstance(annotation, FieldInfo):
                        field_info = annotation
                        break

            if field_info is not None:
                field_value = Field(
                    default=default,
                    description=field_info.description,
                )
            else:
                docstring_description = None
                for arg in param_descriptions.args:
                    if arg.name == param.name:
                        docstring_description = arg.description
                        break
                if docstring_description:
                    field_value = Field(
                        default=default, description=docstring_description
                    )
                else:
                    field_value = default

            field_definitions[param.name] = (param_type, field_value)

        TempModel = create_model("TempModel", **field_definitions)

        schema = TempModel.model_json_schema()

        parameters = ToolParameterSchema(
            properties=schema.get("properties", {}),
            required=schema.get("required", []),
            additionalProperties=False,
        )
        if "$defs" in schema:
            parameters.defs = schema["$defs"]

        return cls(
            name=name, description=description, parameters=parameters, strict=strict
        )

    def defines(self, tool: ToolSchema) -> TypeGuard[Self]:
        """Check if this ToolDef matches a specific Tool instance.

        This method is used to ensure that the ToolDef was created from a specific
        function, allowing for type-safe access to the return value when calling
        the tool.

        Args:
            tool: The Tool instance to compare against.

        Returns:
            True if the ToolDef defines the Tool instance, False otherwise.
        """
        raise NotImplementedError()
