"""Provider-agnostic tool schema representation."""

from __future__ import annotations

import inspect
from collections.abc import Callable
from typing import Annotated, Any, get_args, get_origin, get_type_hints

from pydantic import BaseModel, Field, create_model
from pydantic.fields import FieldInfo

from ..types import Jsonable


class ToolParameterSchema(BaseModel):
    """JSON Schema for tool parameters (always an object with properties).

    This contains real JSON Schema as generated by Pydantic, with full support
    for complex schemas like anyOf, nested objects, validation constraints, etc.
    Including $defs for complex type references.
    """

    properties: dict[str, dict[str, Any]] = Field(default_factory=dict)
    """Dictionary mapping parameter names to their JSON Schema definitions."""

    required: list[str] = Field(default_factory=list)
    """List of required parameter names."""

    additionalProperties: bool = False
    """Whether additional properties beyond those defined are allowed."""

    defs: dict[str, dict[str, Any]] | None = Field(default=None, alias="$defs")
    """JSON Schema definitions for complex types referenced via $ref."""


class ToolSchema(BaseModel):
    """Provider-agnostic tool schema that encodes tool metadata.

    This class represents the core tool information that underpins the various Tool
    classes, and may be converted into a provider-specific representation.
    """

    name: str
    """The name of the tool, used by the LLM to identify which tool to call."""

    description: str
    """Description of what the tool does, extracted from the function's docstring."""

    parameters: ToolParameterSchema = Field(default_factory=ToolParameterSchema)
    """JSON Schema describing the parameters accepted by the tool."""

    strict: bool = False
    """Whether the tool should use strict mode when supported by the model."""

    @classmethod
    def from_function(
        cls, fn: Callable[..., Jsonable], *, strict: bool = False
    ) -> ToolSchema:
        """Create a `ToolSchema` by inspecting a function and its docstring.

        Uses Pydantic's create_model to dynamically build a model from the function
        signature, then extracts the JSON schema from it. This leverages Pydantic's
        robust type conversion and union handling.

        Args:
            fn: The function to extract schema from
            strict: Whether the tool should use strict mode when supported

        Returns:
            a `ToolSchema` representing the function
        """
        name = fn.__name__
        description = inspect.cleandoc(fn.__doc__) if fn.__doc__ else name

        field_definitions = {}
        hints = get_type_hints(fn, include_extras=True)

        for param in inspect.signature(fn).parameters.values():
            if param.name in ("self", "cls"):
                continue

            param_type = hints.get(param.name, Any)
            default = ... if param.default is inspect.Parameter.empty else param.default

            if get_origin(param_type) is Annotated:
                # TODO: Consider handling FromCallArgs here for injecting call args into tools directly
                args = get_args(param_type)
                core_type = args[0]

                field_info = None
                for annotation in args[1:]:
                    if isinstance(annotation, FieldInfo):
                        field_info = annotation
                        break

                if field_info is not None:
                    new_field_info = Field(
                        default=default,
                        description=field_info.description,
                    )
                    field_definitions[param.name] = (core_type, new_field_info)
                else:
                    field_definitions[param.name] = (core_type, default)
            else:
                field_definitions[param.name] = (param_type, default)

        TempModel = create_model("TempModel", **field_definitions)

        schema = TempModel.model_json_schema()

        parameters = ToolParameterSchema(
            properties=schema.get("properties", {}),
            required=schema.get("required", []),
            additionalProperties=False,
        )
        if "$defs" in schema:
            parameters.defs = schema["$defs"]

        return cls.model_construct(  # use model_construct to skip validation
            name=name, description=description, parameters=parameters, strict=strict
        )
