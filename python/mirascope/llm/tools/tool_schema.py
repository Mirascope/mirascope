"""The `ToolSchema` class for defining tools that LLMs can request be called."""

from __future__ import annotations

import inspect
from collections.abc import Awaitable, Callable
from dataclasses import dataclass
from typing import (
    Annotated,
    Any,
    Generic,
    TypeGuard,
    get_args,
    get_origin,
    get_type_hints,
)

from pydantic import BaseModel, Field, create_model
from pydantic.fields import FieldInfo
from typing_extensions import Self

from ..types import Jsonable, JsonableCovariantT, P


class ToolParameterSchema(BaseModel):
    """JSON Schema for tool parameters (always an object with properties).

    This contains real JSON Schema as generated by Pydantic, with full support
    for complex schemas like anyOf, nested objects, validation constraints, etc.
    Including $defs for complex type references.
    """

    properties: dict[str, dict[str, Any]] = Field(default_factory=dict)
    """Dictionary mapping parameter names to their JSON Schema definitions."""

    required: list[str] = Field(default_factory=list)
    """List of required parameter names."""

    additionalProperties: bool = False
    """Whether additional properties beyond those defined are allowed."""

    defs: dict[str, dict[str, Any]] | None = Field(default=None, alias="$defs")
    """JSON Schema definitions for complex types referenced via $ref."""


@dataclass
class ToolSchema(Generic[P, JsonableCovariantT]):
    """Base class defining a tool that can be used by LLMs.

    A Tool represents a function that can be called by an LLM during a call.
    It includes metadata like name, description, and parameter schema.

    This class is not instantiated directly but created by the `@tool()` decorator.
    """

    name: str
    """The name of the tool, used by the LLM to identify which tool to call."""

    description: str
    """Description of what the tool does, extracted from the function's docstring."""

    parameters: ToolParameterSchema
    """JSON Schema describing the parameters accepted by the tool."""

    strict: bool
    """Whether the tool should use strict mode when supported by the model."""

    @classmethod
    def create_schema(
        cls,
        fn: Callable[..., Jsonable] | Callable[..., Awaitable[Jsonable]],
        *,
        strict: bool = False,
    ) -> ToolSchema:
        """Create a `ToolSchema` by inspecting a function and its docstring.

        Uses Pydantic's create_model to dynamically build a model from the function
        signature, then extracts the JSON schema from it. This leverages Pydantic's
        robust type conversion and union handling.

        Args:
            fn: The function to extract schema from
            strict: Whether the tool should use strict mode when supported

        Returns:
            a `ToolSchema` representing the function
        """
        name = fn.__name__
        description = inspect.cleandoc(fn.__doc__) if fn.__doc__ else name

        field_definitions = {}
        hints = get_type_hints(fn, include_extras=True)

        for param in inspect.signature(fn).parameters.values():
            if param.name in ("self", "cls"):
                continue

            param_type = hints.get(param.name, Any)
            default = ... if param.default is inspect.Parameter.empty else param.default

            if get_origin(param_type) is Annotated:
                args = get_args(param_type)
                core_type = args[0]

                field_info = None
                for annotation in args[1:]:
                    if isinstance(annotation, FieldInfo):
                        field_info = annotation
                        break

                if field_info is not None:
                    new_field_info = Field(
                        default=default,
                        description=field_info.description,
                    )
                    field_definitions[param.name] = (core_type, new_field_info)
                else:
                    field_definitions[param.name] = (core_type, default)
            else:
                field_definitions[param.name] = (param_type, default)

        TempModel = create_model("TempModel", **field_definitions)

        schema = TempModel.model_json_schema()

        parameters = ToolParameterSchema(
            properties=schema.get("properties", {}),
            required=schema.get("required", []),
            additionalProperties=False,
        )
        if "$defs" in schema:
            parameters.defs = schema["$defs"]

        return cls(
            name=name, description=description, parameters=parameters, strict=strict
        )

    def defines(self, tool: ToolSchema) -> TypeGuard[Self]:
        """Check if this ToolDef matches a specific Tool instance.

        This method is used to ensure that the ToolDef was created from a specific
        function, allowing for type-safe access to the return value when calling
        the tool.

        Args:
            tool: The Tool instance to compare against.

        Returns:
            True if the ToolDef defines the Tool instance, False otherwise.
        """
        raise NotImplementedError()
