"""Concrete LLM response implementation."""

from collections.abc import Sequence
from typing import TYPE_CHECKING, Any

from ..content import Text, Thinking, ToolCall
from ..formatting import FormatT
from ..messages import AssistantMessage, Message
from .base_response import BaseResponse
from .finish_reason import FinishReason

if TYPE_CHECKING:
    from ..clients import Model, Provider


class Response(BaseResponse[FormatT]):
    """The response generated by an LLM."""

    def __init__(
        self,
        *,
        provider: "Provider",
        model: "Model",
        input_messages: Sequence[Message],
        assistant_message: AssistantMessage,
        finish_reason: FinishReason | None,
        raw: Any,  # noqa: ANN401
    ) -> None:
        """Initialize a Response.

        Args:
            model: The model identifier that generated the response.
            input_messages: The message history before the final assistant message.
            assistant_message: The final assistant message containing the response content.
            raw: The raw response from the LLM.
            finish_reason: The reason why the LLM finished generating a response.
        """
        self.provider = provider
        self.model = model
        self.raw = raw
        self.finish_reason = finish_reason

        self.messages = list(input_messages) + [assistant_message]
        self.content = assistant_message.content

        self.texts, self.tool_calls, self.thinkings = [], [], []
        for part in self.content:
            if isinstance(part, Text):
                self.texts.append(part)
            elif isinstance(part, ToolCall):
                self.tool_calls.append(part)
            elif isinstance(part, Thinking):
                self.thinkings.append(part)
            else:
                raise NotImplementedError

    def format(self) -> FormatT:
        """Format the response according to the response format parser.

        It will parse the response content according to the specified format (if present)
        and return a structured object.

        Returns:
            The formatted response object of type FormatT.

        Raises:
            ValueError: If the response cannot be formatted according to the
                specified format.
        """
        raise NotImplementedError()

    def pretty(self) -> str:
        """Return a string representation of all response content.

        The response content will be represented in a way that emphasies clarity and
        readability, but may not include all metadata (like thinking signatures or tool
        call ids), and thus cannot be used to reconstruct the response. For example:

        **Thinking:**
          The user is asking a math problem. I should use the calculator tool.

        **Tool Call (calculator)** {'operation': 'mult', 'a': 1337, 'b': 4242}

        I am going to use the calculator and answer your question for you!
        """
        if not self.content:
            return "**[No Content]**"

        pretty_parts: list[str] = []
        for part in self.content:
            if isinstance(part, Text):
                pretty_parts.append(part.text)
            elif isinstance(part, ToolCall):
                pretty_parts.append(f"**ToolCall ({part.name}):** {part.args}")
            elif isinstance(part, Thinking):
                indented_thinking = "\n".join(
                    f"  {line}" for line in part.thinking.split("\n")
                )
                pretty_parts.append(f"**Thinking:**\n{indented_thinking}")
            else:
                pretty_parts.append(
                    f"[{type(part).__name__}: {str(part)}]"
                )  # pragma: no cover

        return "\n\n".join(pretty_parts)
