"""Base class for StreamResponse and AsyncStreamResponse."""

from collections.abc import AsyncIterator, Iterator, Sequence
from typing import TYPE_CHECKING, Any, Generic, Literal, TypeAlias, TypeVar

from ..content import (
    AssistantContentChunk,
    AssistantContentPart,
    FinishReasonChunk,
    Text,
    TextChunk,
    TextEndChunk,
    TextStartChunk,
    Thinking,
    ThinkingChunk,
    ThinkingEndChunk,
    ThinkingStartChunk,
    ToolCall,
    ToolCallChunk,
    ToolCallEndChunk,
    ToolCallStartChunk,
)
from ..formatting import FormatT
from ..messages import AssistantMessage, Message
from ..tools import FORMAT_TOOL_NAME, ToolkitT
from ..types import NoneType
from .finish_reason import FinishReason
from .response_base import ResponseBase

if TYPE_CHECKING:
    from ..clients import Model, Provider
from dataclasses import dataclass


@dataclass
class RawChunk:
    raw: Any
    type: Literal["raw_chunk"] = "raw_chunk"


ChunkIterator: TypeAlias = Iterator[AssistantContentChunk | RawChunk]
"""Synchronous iterator yielding chunks with raw data."""

AsyncChunkIterator: TypeAlias = AsyncIterator[AssistantContentChunk | RawChunk]
"""Asynchronous iterator yielding chunks with raw data."""

ChunkIteratorT = TypeVar("ChunkIteratorT", bound=ChunkIterator | AsyncChunkIterator)


class BaseStreamResponse(
    ResponseBase[ToolkitT, FormatT], Generic[ChunkIteratorT, ToolkitT, FormatT]
):
    """Base class underpinning StreamResponse and AsyncStreamResponse.

    Manages chunk handling logic for both.
    """

    raw: Sequence[Any]
    """The raw chunks from the LLM."""

    chunks: Sequence[AssistantContentChunk]
    """All of the raw chunks consumed from the stream."""

    content: Sequence[AssistantContentPart]
    """The content generated by the LLM.
    
    Content is updated in this array as it is consumed by the stream. Text content will 
    update with each text chunk (this will mutate the Text object that is returned 
    rather than creating a new one). Other content will be added once each part
    is fully streamed.
    """

    messages: list[Message]
    """The message history, including the most recent assistant message.

    The most recent assistant message will have all of the completed content that has 
    already been consumed from the stream. Text content will be included as each chunk 
    is processed; other content will be included only when its corresponding part is 
    completed (to avoid partial tool calls and the like). If no content has been 
    streamed, then the final assistant message will be present (to maintain turn order 
    expectations), but will be empty.
    """

    texts: Sequence[Text]
    """The text content in the generated response, if any.
    
    Text content updates with each text chunk as it streams. The Text objects are 
    mutated in place rather than creating new ones for each chunk.
    """

    tool_calls: Sequence[ToolCall]
    """The tools the LLM wants called on its behalf, if any.
    
    Tool calls are only added to this sequence once they have been fully streamed 
    to avoid partial tool calls in the response.
    """

    thinkings: Sequence[Thinking]
    """The thinking content in the generated response, if any.
    
    Thinking content is only added to this sequence once it has been fully streamed 
    to avoid partial thinking blocks in the response.
    """

    consumed: bool = False
    """Whether the stream has been fully consumed.
    
    This is True after all chunks have been processed from the underlying iterator.
    When False, more content may be available by calling the stream methods.
    """

    def __init__(
        self,
        *,
        provider: "Provider",
        model: "Model",
        toolkit: ToolkitT,
        format: type[FormatT] = NoneType,
        input_messages: Sequence[Message],
        chunk_iterator: ChunkIteratorT,
    ) -> None:
        """Initialize the BaseStreamResponse.

        Args:
            provider: The provider name (e.g., "anthropic", "openai")
            model: The model identifier
            input_messages: The input messages that were sent to the LLM

        The BaseStreamResponse will process the tuples to build the chunks and raw lists
        as the stream is consumed.
        """

        self.provider = provider
        self.model = model
        self.toolkit = toolkit
        self.format_type = format

        # Internal-only lists which we mutate (append) during chunk processing
        self._chunks: list[AssistantContentChunk] = []
        self._content: list[AssistantContentPart] = []
        self._texts: list[Text] = []
        self._thinkings: list[Thinking] = []
        self._tool_calls: list[ToolCall] = []
        self._raw: list[Any] = []
        self._last_raw_chunk: Any | None = None

        # Externally-facing references typed as immutable Sequences
        self.chunks = self._chunks
        self.content = self._content
        self.texts = self._texts
        self.thinkings = self._thinkings
        self.tool_calls = self._tool_calls
        self.raw = self._raw

        self.finish_reason = None

        self.messages = list(input_messages) + [AssistantMessage(content=self._content)]

        self._chunk_iterator = chunk_iterator
        self._current_content: Text | Thinking | ToolCall | None = None

        self._found_format_tool = False
        self._processing_format_tool = False

    def _transform_format_tool_chunks(
        self, chunk: AssistantContentChunk
    ) -> AssistantContentChunk:
        if chunk.type == "tool_call_start_chunk" and chunk.name == FORMAT_TOOL_NAME:
            self._found_format_tool = True
            self._processing_format_tool = True
            return TextStartChunk()
        if self._processing_format_tool and chunk.type == "tool_call_chunk":
            return TextChunk(delta=chunk.delta)
        if self._processing_format_tool and chunk.type == "tool_call_end_chunk":
            self._processing_format_tool = False
            return TextEndChunk()
        if (
            self._found_format_tool
            and chunk.type == "finish_reason_chunk"
            and chunk.finish_reason == FinishReason.TOOL_USE
        ):
            return FinishReasonChunk(finish_reason=FinishReason.END_TURN)
        return chunk

    def _handle_chunk(self, chunk: AssistantContentChunk) -> AssistantContentChunk:
        chunk = self._transform_format_tool_chunks(chunk)

        if self.finish_reason is not None:
            raise RuntimeError(
                f"Stream already finished with reason: {self.finish_reason}"
            )
        if chunk.type == "finish_reason_chunk":
            self.finish_reason = chunk.finish_reason
        elif chunk.content_type == "text":
            self._handle_text_chunk(chunk)
        elif chunk.content_type == "thinking":
            self._handle_thinking_chunk(chunk)
        elif chunk.content_type == "tool_call":
            self._handle_tool_call_chunk(chunk)
        else:
            raise NotImplementedError

        self._chunks.append(chunk)
        return chunk

    def _handle_text_chunk(
        self, chunk: TextStartChunk | TextChunk | TextEndChunk
    ) -> None:
        if chunk.type == "text_start_chunk":
            if self._current_content:
                raise RuntimeError(
                    "Received text_start_chunk while processing another chunk"
                )
            self._current_content = Text(text="")
            # Text gets included in content even when unfinished.
            self._content.append(self._current_content)
            self._texts.append(self._current_content)

        elif chunk.type == "text_chunk":
            if self._current_content is None or self._current_content.type != "text":
                raise RuntimeError("Received text_chunk while not processing text.")
            self._current_content.text += chunk.delta

        elif chunk.type == "text_end_chunk":
            if self._current_content is None or self._current_content.type != "text":
                raise RuntimeError("Received text_end_chunk while not processing text.")
            self._current_content = None

    def _handle_thinking_chunk(
        self, chunk: ThinkingStartChunk | ThinkingChunk | ThinkingEndChunk
    ) -> None:
        if chunk.type == "thinking_start_chunk":
            if self._current_content:
                raise RuntimeError(
                    "Received thinking_start_chunk while processing another chunk"
                )
            new_thinking = Thinking(thinking="", signature=None)
            self._current_content = new_thinking

        elif chunk.type == "thinking_chunk":
            if (
                self._current_content is None
                or self._current_content.type != "thinking"
            ):
                raise RuntimeError(
                    "Received thinking_chunk while not processing thinking."
                )
            self._current_content.thinking += chunk.delta

        elif chunk.type == "thinking_end_chunk":
            if (
                self._current_content is None
                or self._current_content.type != "thinking"
            ):
                raise RuntimeError(
                    "Received thinking_end_chunk while not processing thinking."
                )
            # Only add to content and thinkings when complete
            self._current_content.signature = chunk.signature
            self._content.append(self._current_content)
            self._thinkings.append(self._current_content)
            self._current_content = None

    def _handle_tool_call_chunk(
        self, chunk: ToolCallStartChunk | ToolCallChunk | ToolCallEndChunk
    ) -> None:
        if chunk.type == "tool_call_start_chunk":
            if self._current_content:
                raise RuntimeError(
                    "Received tool_call_start_chunk while processing another chunk"
                )
            self._current_content = ToolCall(
                id=chunk.id,
                name=chunk.name,
                args="",
            )

        elif chunk.type == "tool_call_chunk":
            if (
                self._current_content is None
                or self._current_content.type != "tool_call"
            ):
                raise RuntimeError(
                    "Received tool_call_chunk while not processing tool call."
                )
            self._current_content.args += chunk.delta

        elif chunk.type == "tool_call_end_chunk":
            if (
                self._current_content is None
                or self._current_content.type != "tool_call"
            ):
                raise RuntimeError(
                    "Received tool_call_end_chunk while not processing tool call."
                )
            if not self._current_content.args:
                self._current_content.args = "{}"
            self._content.append(self._current_content)
            self._tool_calls.append(self._current_content)
            self._current_content = None

    def _pretty_chunk(self, chunk: AssistantContentChunk, spacer: str) -> str:
        match chunk.type:
            case "text_start_chunk":
                return spacer
            case "thinking_start_chunk":
                return spacer + "**Thinking:**\n  "
            case "tool_call_start_chunk":
                return spacer + f"**ToolCall ({chunk.name}):** "
            case "text_chunk":
                return chunk.delta
            case "thinking_chunk":
                return chunk.delta.replace("\n", "\n  ")  # Indent every line
            case "tool_call_chunk":
                return chunk.delta
            case _:
                return ""
