"""Shared base of Response and AsyncResponse."""

from collections.abc import Sequence
from typing import TYPE_CHECKING, Any

from ..content import Text, Thinking, ToolCall
from ..formatting import FormatT
from ..messages import AssistantMessage, Message
from ..tools import FORMAT_TOOL_NAME, ToolkitT
from .finish_reason import FinishReason
from .root_response import RootResponse

if TYPE_CHECKING:
    from ..clients import BaseParams, ModelId, Provider


class BaseResponse(RootResponse[ToolkitT, FormatT]):
    """The response generated by an LLM."""

    def __init__(
        self,
        *,
        raw: Any,  # noqa: ANN401
        provider: "Provider",
        model_id: "ModelId",
        params: "BaseParams | None",
        toolkit: ToolkitT,
        format_type: type[FormatT] | None = None,
        input_messages: Sequence[Message],
        assistant_message: AssistantMessage,
        finish_reason: FinishReason | None,
    ) -> None:
        """Initialize a Response.

        Args:
            raw: The raw response from the LLM.
            provider: The provider name (e.g. "anthropic", "openai").
            model_id: The model identifier that generated the response.
            params: The params used to generate the response (or None).
            toolkit: Toolkit containing all the tools used to generate the response.
            format_type: The type for the expected structured output format (or None).
            input_messages: The message history before the final assistant message.
            assistant_message: The final assistant message containing the response content.
            finish_reason: The reason why the LLM finished generating a response.
        """
        self.raw = raw
        self.provider = provider
        self.model_id = model_id
        self.params = params
        self.toolkit = toolkit
        self.finish_reason = finish_reason
        self.format_type = format_type

        self.messages = list(input_messages) + [assistant_message]

        found_format_tool = False
        self.texts, self.tool_calls, self.thoughts, self.content = [], [], [], []
        for part in assistant_message.content:
            if isinstance(part, ToolCall) and part.name == FORMAT_TOOL_NAME:
                part = Text(text=part.args)
                found_format_tool = True

            self.content.append(part)
            if isinstance(part, Text):
                self.texts.append(part)
            elif isinstance(part, ToolCall):
                self.tool_calls.append(part)
            elif isinstance(part, Thinking):
                self.thoughts.append(part)
            else:
                raise NotImplementedError

        if found_format_tool and self.finish_reason == FinishReason.TOOL_USE:
            self.finish_reason = FinishReason.END_TURN
