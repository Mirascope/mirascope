"""The `llm.format` decorator for defining response formats as classes."""

import inspect
import json
from dataclasses import dataclass, replace
from typing import Any, Generic, cast

from pydantic import BaseModel

from ..tools import FORMAT_TOOL_NAME, ToolFn, ToolParameterSchema, ToolSchema
from ..types import NoneType
from .from_call_args import is_from_call_args
from .types import FormattableT, FormattingMode, HasFormattingInstructions

TOOL_MODE_INSTRUCTIONS = f"""Always respond to the user's query using the {FORMAT_TOOL_NAME} tool for structured output."""


JSON_MODE_INSTRUCTIONS = (
    "Respond only with valid JSON that matches this exact schema:\n{json_schema}"
)


@dataclass(kw_only=True)
class Format(Generic[FormattableT]):
    """Class representing a structured output format for LLM responses.

    A `Format` contains metadata needed to describe a structured output type
    to the LLM, including the expected schema. This class is not instantiated directly,
    but is created by calling `llm.format`, or is automatically generated by LLM
    providers when a `Formattable` is passed to a call method.

    Example:

      ```python
      from mirascope import llm

      class Book:
          title: str
          author: str

      print(llm.format(Book, mode="tool"))
      ```
    """

    name: str
    """The name of the response format."""

    description: str | None
    """A description of the response format, if available."""

    schema: dict[str, object]
    """JSON schema representation of the structured output format."""

    mode: FormattingMode | None
    """The decorator-provided mode of the response format. 
    
    Determines how the LLM call may be modified in order to extract the expected format.
    """

    from_call_args_fields: set[str]
    """The field names in the model that are marked `FromCallArgs` (if any)."""

    formattable: type[FormattableT]
    """The `Formattable` type that this `Format` describes.
    
    While the `FormattbleT` typevar allows for `None`, a `Format` will never be
    constructed when the `FormattableT` is `None`, so you may treat this as 
    a `RequiredFormattableT` in practice.
    """

    @property
    def formatting_instructions(self) -> str | None:
        """The formatting instructions that will be added to the LLM system prompt.

        If the format type has a `formatting_instructions` class method, the output of that
        call will be used for instructions. Otherwise, instructions may be auto-generated
        based on the formatting mode.
        """
        if isinstance(self.formattable, HasFormattingInstructions):
            return self.formattable.formatting_instructions()
        if self.mode == "tool":
            return TOOL_MODE_INSTRUCTIONS
        elif self.mode == "json":
            json_schema = json.dumps(self.schema, indent=2)
            instructions = JSON_MODE_INSTRUCTIONS.format(json_schema=json_schema)
            return inspect.cleandoc(instructions)

    def create_tool_schema(
        self,
    ) -> ToolSchema[ToolFn[..., None]]:
        """Generate a `ToolSchema` for parsing this format.

        Returns:
            `ToolSchema` for the format tool
        """

        schema_dict: dict[str, Any] = self.schema.copy()
        schema_dict["type"] = "object"

        properties = schema_dict.get("properties")
        if not properties or not isinstance(properties, dict):
            properties = {}  # pragma: no cover
        properties = cast(dict[str, Any], properties)
        required: list[str] = list(properties.keys())

        description = (
            f"Use this tool to extract data in {self.name} format for a final response."
        )
        if self.description:
            description += "\n" + self.description

        parameters = ToolParameterSchema(
            properties=properties,
            required=required,
            additionalProperties=False,
        )
        if "$defs" in schema_dict and isinstance(schema_dict["$defs"], dict):
            parameters.defs = schema_dict["$defs"]

        def _unused_format_fn() -> None:
            raise TypeError(
                "Format tool function should not be called."
            )  # pragma: no cover

        tool_schema = cast(
            ToolSchema[ToolFn[..., None]], ToolSchema.__new__(ToolSchema)
        )
        tool_schema.fn = _unused_format_fn
        tool_schema.name = FORMAT_TOOL_NAME
        tool_schema.description = description
        tool_schema.parameters = parameters
        tool_schema.strict = True

        return tool_schema


def _validate_no_nested_from_call_args(model: type[Any], path: str = "") -> None:
    """Recursively validate that nested models don't have FromCallArgs fields.

    Args:
        model: The model to validate
        path: The current path for error messages (e.g., "inner.nested")

    Raises:
        ValueError: If a nested model has FromCallArgs fields
    """
    for name, field in model.model_fields.items():
        field_path = f"{path}.{name}" if path else name

        # Check if this field's annotation is a BaseModel
        if (
            field.annotation
            and isinstance(field.annotation, type)
            and issubclass(field.annotation, BaseModel)
        ):
            # Check if this nested model has FromCallArgs fields
            for nested_name, nested_field in field.annotation.model_fields.items():
                if is_from_call_args(nested_field):
                    raise ValueError(
                        f"FromCallArgs is not allowed on nested model fields. "
                        f"Found on field '{nested_name}' in nested model at '{field_path}'"
                    )
            # Recursively check deeper nesting
            _validate_no_nested_from_call_args(field.annotation, field_path)


def format(
    formattable: type[FormattableT] | None,
    *,
    mode: FormattingMode | None = None,
) -> Format[FormattableT] | None:
    """Returns a `Format` that describes structured output for a Formattable type.

    This function converts a Formattable type (e.g. Pydantic BaseModel) into a `Format`
    object that describes how the object should be formatted. Calling `llm.format`
    is optional, as all the APIs that expect a `Format` can also take the Formattable
    type directly. However, calling `llm.format` is necessary in order to specify the
    formatting mode that will be used.

    Args:
        mode: The format mode to use, one of the following:
            - "strict": Use model strict structured outputs, or fail if unavailable.
            - "tool": Use forced tool calling with a special tool that represents a
              formatted response.
            - "json": Use provider json mode if available, or modify prompt to request
              json if not.

    The Formattable type may provide custom formatting instructions via a
    `formatting_instructions(cls)` classmethod. If that method is present, it will be called,
    and the resulting instructions will automatically be appended to the system prompt.

    If no formatting instructions are present, then Mirascope may auto-generate instructions
    based on the active format mode. To disable this behavior and all prompt modification,
    you can add the `formatting_instructions` classmethod and have it return `None`.

    Returns:
      A `Format` object describing the Formattable type.

    Example:
      Using with an LLM call:

      ```python
      from pydantic import BaseModel

      from mirascope import llm


      class Book(BaseModel):
          title: str
          author: str

      format = llm.format(Book, mode="strict")

      @llm.call(
          provider_id="openai",
          model_id="openai/gpt-5-mini",
          format=format,
      )
      def recommend_book(genre: str):
          return f"Recommend a {genre} book."

      response = recommend_book("fantasy")
      book: Book = response.parse()
      print(f"{book.title} by {book.author}")
      ```
    """
    # TODO: Add caching or memoization to this function (e.g. functools.lru_cache)

    if formattable is None or formattable is NoneType:
        return None

    description = None
    if formattable.__doc__:
        description = inspect.cleandoc(formattable.__doc__)

    schema = formattable.model_json_schema()

    _validate_no_nested_from_call_args(formattable)
    from_call_args_fields = {
        name
        for name, field in formattable.model_fields.items()
        if is_from_call_args(field)
    }
    # Remove FromCallArgs fields from the schema
    if from_call_args_fields:
        # Remove from properties
        properties = schema.get("properties")
        if isinstance(properties, dict):
            properties_dict = cast(dict[str, Any], properties)
            for field_name in from_call_args_fields:
                properties_dict.pop(field_name, None)

        # Remove from required
        required = schema.get("required")
        if isinstance(required, list):
            required_list = cast(list[str], required)
            schema["required"] = [
                req for req in required_list if req not in from_call_args_fields
            ]

    return Format[FormattableT](
        name=formattable.__name__,
        description=description,
        schema=schema,
        mode=mode,
        formattable=formattable,
        from_call_args_fields=from_call_args_fields,
    )


def resolve_format(
    formattable: type[FormattableT] | Format[FormattableT] | None,
    default_mode: FormattingMode,
) -> Format[FormattableT] | None:
    """Resolve a `Format` (or None) from a possible `Format` or Formattable."""
    if isinstance(formattable, Format):
        if not formattable.mode:
            return replace(formattable, mode=default_mode)
        return formattable
    else:
        return format(formattable, mode=default_mode)
