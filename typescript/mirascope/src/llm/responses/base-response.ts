/**
 * @fileoverview The `BaseResponse` class for LLM responses.
 */

import type { Audio, Image, Thinking, Video } from '../content';
import type { Message } from '../messages';
import type { BaseResponseContent } from './content';
import type { FinishReason } from './finish-reason';
import type { Usage } from './usage';
import type { REGISTERED_LLMS } from '../clients';

/**
 * The response generated by an LLM.
 */
export abstract class BaseResponse<
  ResponseContentT extends BaseResponseContent = BaseResponseContent,
  T extends object | null = null,
> {
  /**
   * The raw response from the LLM.
   */
  raw: any;

  /**
   * The model identifier that generated the response (e.g. "openai:gpt-4", "anthropic:claude-3-5-sonnet-latest").
   */
  model: REGISTERED_LLMS;

  /**
   * The arguments used to generate the response.
   */
  args: Record<string, any>;

  /**
   * The string template used to define the messages array, if any.
   */
  template: string | null;

  /**
   * The messages used to generate the response.
   */
  messages: Message[];

  /**
   * The content generated by the LLM.
   */
  content: ResponseContentT[];

  /**
   * The text content in the generated response, if any.
   */
  texts: string[];

  /**
   * The image content in the generated response, if any.
   */
  images: Image[];

  /**
   * The audio content in the generated response, if any.
   */
  audios: Audio[];

  /**
   * The video content in the generated response, if any.
   */
  videos: Video[];

  /**
   * The thinking content in the generated response, if any.
   */
  thinkings: Thinking[];

  /**
   * The reason why the LLM finished generating a response.
   */
  finishReason: FinishReason;

  /**
   * The token usage statistics for the request to the LLM.
   */
  usage: Usage | null;

  /**
   * The cost of the request to the LLM, if available.
   */
  cost: number | null; // Using number instead of Decimal for TypeScript

  constructor(
    raw: any,
    model: REGISTERED_LLMS,
    args: Record<string, any>,
    template: string | null,
    messages: Message[],
    content: ResponseContentT[],
    texts: string[],
    images: Image[],
    audios: Audio[],
    videos: Video[],
    thinkings: Thinking[],
    finishReason: FinishReason,
    usage: Usage | null,
    cost: number | null
  ) {
    this.raw = raw;
    this.model = model;
    this.args = args;
    this.template = template;
    this.messages = messages;
    this.content = content;
    this.texts = texts;
    this.images = images;
    this.audios = audios;
    this.videos = videos;
    this.thinkings = thinkings;
    this.finishReason = finishReason;
    this.usage = usage;
    this.cost = cost;
  }

  /**
   * Returns the first text in the response content, if any.
   */
  get text(): string | null {
    return this.texts.length > 0 ? this.texts[0]! : null;
  }

  /**
   * Returns the first image in the response content, if any.
   */
  get image(): Image | null {
    return this.images.length > 0 ? this.images[0]! : null;
  }

  /**
   * Returns the first audio in the response content, if any.
   */
  get audio(): Audio | null {
    return this.audios.length > 0 ? this.audios[0]! : null;
  }

  /**
   * Returns the first video in the response content, if any.
   */
  get video(): Video | null {
    return this.videos.length > 0 ? this.videos[0]! : null;
  }

  /**
   * Returns the first thinking in the response content, if any.
   */
  get thinking(): Thinking | null {
    return this.thinkings.length > 0 ? this.thinkings[0]! : null;
  }

  /**
   * Format the response according to the response format parser.
   *
   * This method is only available if the call was created with a T.
   * It will parse the response content according to the specified format and return
   * a structured object.
   *
   * @returns The formatted response object of type T.
   * @throws Error if the response cannot be formatted according to the specified format.
   */
  format(): T {
    throw new Error('Not implemented');
  }

  /**
   * Return a string representation of all response content including embedded media.
   *
   * The resulting string includes all raw text directly, and includes placeholder
   * representations for embedded media, eg {image: url=...} or {thinking: thoughts=...}
   *
   * Each content piece will be separated by newlines.
   */
  toString(): string {
    throw new Error('Not implemented');
  }
}
